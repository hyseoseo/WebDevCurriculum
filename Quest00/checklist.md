# 형상관리 시스템은 왜 나오게 되었을까요?

형상 관리 시스템이란 개발 중 발생하는 산출물들의 변경에 따라 점차 변해가는 소프트웨어의 형상을 체계적으로 관리하고 유지하는 체계입니다. 소프트웨어는 필연적으로 사용자의 요구에 따라 지속적으로 변경됩니다. 형상관리 시스템을 사용하여 이 변경하는 상태에 대한 가시성을 확보할 수 있고, 누가, 언제, 무엇을, 어떻게, 왜 변경하였는지 기록할 수 있습니다. 만약 요구사항 변경과 산출물 이력이 관리되지 않고 관련자들에게 변경 내용이 제대로 전달되지 않는다면, 이중 작업이나 작업 결과물 사이의 충돌이 발생하여 개발 생산성과 품질이 저하될 것입니다. 형상 관리 시스템을 이용하면 변화에 대한 관리를 통해 전체 시스템과의 통합을 보장할 수 있어 개발 생산성, 안정성을 높이고 유지보수를 용이하게 할 수 있습니다.
<br>
<br>

# git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있을까요? 분산형 형상관리 시스템이란 무엇일까요?

형상(버전)관리 방식에는 두 가지 종류가 있습니다.

## 중앙 집중형

- 중앙 서버에 올라간 소스코드를 내려받아 작업하고, 작업 완료된 결과물을 커밋하여 다시 서버로 올려보내는 방식
- 커밋한 내용이 모든 작업자에게 바로 영향이 간다. 충돌 발생하기 쉽다
- 서버 상태에 따라 update나 commit을 하지 못하는 순간이 발생한다

## 분산 관리 방식

- 주로 로컬에서 작업을 진행하다가 올리고자 하는 내용을 로컬 저장소로 올려서 작업한 내용의 이력을 관리한다
- 로컬저장소에 올리기 때문에 커밋에 부담이 없어져서 파일 유실 염려 적어지고 작업 이력 관리 효율성 증대
- 로컬저장소에 각자 이력이 관리되므로 중앙서버가 다운되어도 복구가 쉽다
- 하나의 파일에 대해 작업자 별로 다른 작업을 하고 이력을 별도 관리할 수 있다

깃은 분산 관리 방식을 사용하는 형상관리 시스템이기 때문에 각자 독립성을 유지하며 동시에 작업을 진행할 수 있습니다.
깃의 특징은 아래와 같습니다.

- branch를 생성하여 개발을 진행하고 merge를 통해 메인 코드에 병합할 수 있음
- 대부분 작업이 개발자 로컬 환경에서 진행되기 때문에 속도가 빠름 (중앙 서버가 해야 할 일이 줄어든다)
- 각 사용자들이 메인코드 전체를 가지고 있기 때문에 서버 다운 등의 문제에 대응하기 용이
- 모든 파일은 커밋 아이디 체크 검사를 거치며 누가 어느 파일을 작업했는지 기록을 남길 수 있음
- staging area가 별도로 있어서 수정한 내용을 반영하기 전 검토할 수 있음
- 오픈 소스
  <br>
  <br>

# git은 어떻게 개발되게 되었을까요? git이 분산형 시스템을 채택한 이유는 무엇일까요?

git은 Linux를 만든 찐천재 리누스 토발즈의 오픈소스 프로젝트로, 역시 오픈소스인 Linux의 원활한 개발 관리를 지원하기 위한 목적으로 개발되었습니다.
전세계 개발자가 온라인이든 오프라인이든 가리지 않고 개발하고 기여할 수 있는 오픈소스 프로젝트의 버전 관리를 위해서 브랜치를 통한 비선형적 개발 방식과 완벽한 분산 체계를 지원하게 되었습니다.

# git과 GitHub은 어떻게 다를까요?

github(gitlab, bitbucket 등)은 git 사용을 위한 원격 저장소 호스트 서비스입니다.
원격 저장소를 개발자가 개별적으로 로컬에 두고 관리하기 어렵기 때문에 24시간 접속이 가능한 원격 저장소 서비스가 생겨나게 되었습니다.

# git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?

## clone

- git clone {url}
- 기존 소스코드 다운로드 / 복제. github repo 먼저 만들고 로컬에서 작업 시작할 때 빈 repo를 클론하기도.
- clone 했을 때 내부의 모든 파일은 tracked(git의 관리대상) 파일이다

## add

- git add (파일명) / git add . (모든 변경 사항 staging)
- argument가 directory 경로이면 서브 디렉토리 모두 포함
- stage에 파일 변경 사항을 올림 (add되지 않은 파일은 unstaged 상태임)
- staged는 commit으로 저장소에 기록할 파일들의 상태

## commit

- git commit -m "commit message"
- 프로젝트의 스냅샷을 기록한다. 이후에 스냅샷끼리 비교하거나 예전 스냅샷 상태로도 되돌릴 수 있다
- -a 옵션을 추가하면 add 명령어를 생략(tracked 파일을 자동으로 staging)하고 바로 커밋할 수 있다
- --amend 옵션으로 살짝 빠뜨리거나 변경하거나 커밋 메시지 잘못 적었을 때 완료한 커밋 수정할 수 있다

## push

- git push {원격저장소 주소} / git push {원격저장소명} {브랜치명}으로 주로 사용
- (git remote add origin 등으로 연결되어 있는) 원격 저장소에 변경사항을 update한다
- 머지하지 않고 변경사항만 가져올 때는 git fetch 이용

## pull

- git pull {원격저장소명} {브랜치명}
- 원격 저장소의 변경 사항을 가져오고 머지한다

## branch

- git branch {브랜치명}
- 새로운 브랜치를 만드는 명령어. 브랜치를 옮기지는 않는다
- git checkout {브랜치명} 헤드가 체크아웃한 브랜치를 가리킨다
- git checkout -b {브랜치명} 브랜치를 새로 생성하며 체크아웃한다
- 브랜치를 이동하면 워킹 디렉토리의 파일이 가장 마지막으로 했던 작업 내용으로 변경된다
- commit이나 stash 등으로 워킹 디렉토리를 정리하고 브랜치를 이동해야 한다
- git branch -d {브랜치명} 브랜치를 삭제한다

## stash

- git stash
- 로컬에서 변경한 내용을 쉽게 버릴 수는 없는데 당장 이전 커밋 상태로 되돌려야 하는 상황에서 사용한다

## rm

- git rm (파일명, 폴더명)
- staging area에서 파일을 삭제하고 워킹 디렉토리 실제 파일도 삭제한다
- git rm 하지 않고 파일을 삭제하면 unstaged 상태가 된다
- git rm --cached는 워킹 디렉토리 파일은 지우지 않고 남겨둔다. (gitignore 깜빡하고 노드 모듈 add했을 때 사용...)

# git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까요?

## Head

지금 작업하는 로컬 브랜치를 가리키는 포인터

# 리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요?

# Reference

- 형상 관리의 개념과 절차 (쉽게 배우는 소프트웨어 공학) https://terms.naver.com/entry.naver?docId=3533073&cid=58528&categoryId=58528
